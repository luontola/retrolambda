// Copyright Â© 2013-2015 Esko Luontola <www.orfjackal.net>
// This software is released under the Apache License 2.0.
// The license text is at http://www.apache.org/licenses/LICENSE-2.0

package net.orfjackal.retrolambda;

import org.objectweb.asm.Opcodes;

import java.io.*;
import java.nio.file.*;
import java.util.*;
import java.util.stream.*;

public class Config {

    private static final String PREFIX = "retrolambda.";
    public static final String BYTECODE_VERSION = PREFIX + "bytecodeVersion";
    public static final String DEFAULT_METHODS = PREFIX + "defaultMethods";
    public static final String INPUT_DIR = PREFIX + "inputDir";
    public static final String OUTPUT_DIR = PREFIX + "outputDir";
    public static final String CLASSPATH = PREFIX + "classpath";
    public static final String CLASSPATH_FILE = CLASSPATH + "File";
    public static final String INCLUDED_FILES = PREFIX + "includedFiles";
    public static final String INCLUDED_FILES_FILE = INCLUDED_FILES + "File";

    private static final List<String> requiredProperties = new ArrayList<>();
    private static final List<String> requiredPropertiesHelp = new ArrayList<>();
    private static final List<String> optionalPropertiesHelp = new ArrayList<>();
    private static final Map<Integer, String> bytecodeVersionNames = new HashMap<>();

    static {
        bytecodeVersionNames.put(Opcodes.V1_1, "Java 1.1");
        bytecodeVersionNames.put(Opcodes.V1_2, "Java 1.2");
        bytecodeVersionNames.put(Opcodes.V1_3, "Java 1.3");
        bytecodeVersionNames.put(Opcodes.V1_4, "Java 1.4");
        bytecodeVersionNames.put(Opcodes.V1_5, "Java 5");
        bytecodeVersionNames.put(Opcodes.V1_6, "Java 6");
        bytecodeVersionNames.put(Opcodes.V1_7, "Java 7");
        bytecodeVersionNames.put(Opcodes.V1_8, "Java 8");
    }

    private final Properties p;

    public Config(Properties p) {
        this.p = p;
    }

    public boolean isFullyConfigured() {
        return hasAllRequiredProperties();
    }

    private boolean hasAllRequiredProperties() {
        for (String requiredParameter : requiredProperties) {
            if (p.getProperty(requiredParameter) == null) {
                return false;
            }
        }
        return true;
    }


    // bytecode version

    static {
        optionalParameterHelp(BYTECODE_VERSION,
                "Major version number for the generated bytecode. For a list, see",
                "offset 7 at http://en.wikipedia.org/wiki/Java_class_file#General_layout",
                "Default value is " + Opcodes.V1_7 + " (i.e. Java 7)");
    }

    public int getBytecodeVersion() {
        return Integer.parseInt(p.getProperty(BYTECODE_VERSION, "" + Opcodes.V1_7));
    }

    public String getJavaVersion() {
        return bytecodeVersionNames.getOrDefault(getBytecodeVersion(), "unknown version");
    }


    // default methods

    static {
        optionalParameterHelp(DEFAULT_METHODS,
                "Whether to backport default methods and static methods on interfaces.",
                "LIMITATIONS: All backported interfaces and all classes which implement",
                "them or call their static methods must be backported together,",
                "with one execution of Retrolambda.",
                "Disabled by default. Enable by setting to \"true\"");

    }

    public boolean isDefaultMethodsEnabled() {
        return Boolean.parseBoolean(p.getProperty(DEFAULT_METHODS, "false"));
    }


    // input dir

    static {
        requiredParameterHelp(INPUT_DIR,
                "Input directory from where the original class files are read.");
    }

    public Path getInputDir() {
        String inputDir = p.getProperty(INPUT_DIR);
        if (inputDir != null) {
            return Paths.get(inputDir);
        }
        throw new IllegalArgumentException("Missing required property: " + INPUT_DIR);
    }


    // output dir

    static {
        optionalParameterHelp(OUTPUT_DIR,
                "Output directory into where the generated class files are written.",
                "Defaults to same as " + INPUT_DIR);
    }

    public Path getOutputDir() {
        String outputDir = p.getProperty(OUTPUT_DIR);
        if (outputDir != null) {
            return Paths.get(outputDir);
        }
        return getInputDir();
    }


    // classpath

    static {
        requiredParameterHelp(CLASSPATH,
                "Classpath containing the original class files and their dependencies.",
                "Uses ; or : as the path separator, see java.io.File#pathSeparatorChar");
        optionalParameterHelp(CLASSPATH_FILE,
                "File listing the classpath entries.",
                "Alternative to " + CLASSPATH + " for avoiding the command line",
                "length limit. The file must list one file per line with UTF-8 encoding.");
    }

    public List<Path> getClasspath() {
        String classpath = p.getProperty(CLASSPATH);
        if (classpath != null) {
            return Stream.of(classpath.split(File.pathSeparator))
                    .filter(path -> !path.isEmpty())
                    .map(Paths::get)
                    .collect(Collectors.toList());
        }
        String classpathFile = p.getProperty(CLASSPATH_FILE);
        if (classpathFile != null) {
            try {
                return Files.readAllLines(Paths.get(classpathFile)).stream()
                        .filter(line -> !line.isEmpty())
                        .map(Paths::get)
                        .collect(Collectors.toList());
            } catch (IOException e) {
                throw new RuntimeException("Failed to read " + CLASSPATH_FILE + " from " + classpathFile, e);
            }
        }
        throw new IllegalArgumentException("Missing required property: " + CLASSPATH);
    }


    // incremental files

    static {
        optionalParameterHelp(INCLUDED_FILES,
                "List of files to process, instead of processing all files.",
                "This is useful for a build tool to support incremental compilation.",
                "Uses ; or : as the path separator, see java.io.File#pathSeparatorChar");
        optionalParameterHelp(INCLUDED_FILES_FILE,
                "File listing the files to process, instead of processing all files.",
                "Alternative to " + INCLUDED_FILES + " for avoiding the command line",
                "length limit. The file must list one file per line with UTF-8 encoding.");
    }

    public List<Path> getIncludedFiles() {
        String files = p.getProperty(INCLUDED_FILES);
        if (files != null) {
            return Arrays.asList(files.split(File.pathSeparator)).stream()
                    .filter(s -> !s.isEmpty())
                    .map(Paths::get)
                    .collect(Collectors.toList());
        }
        String filesFile = p.getProperty(INCLUDED_FILES_FILE);
        if (filesFile != null) {
            try {
                return Files.readAllLines(Paths.get(filesFile))
                        .stream()
                        .filter(path -> !path.isEmpty())
                        .map(Paths::get)
                        .collect(Collectors.toList());
            } catch (IOException e) {
                throw new RuntimeException("Failed to read " + INCLUDED_FILES_FILE + " from " + filesFile, e);
            }
        }
        return null;
    }


    // help

    public String getHelp() {
        String options = requiredProperties.stream()
                .map(key -> "-D" + key + "=?")
                .reduce((a, b) -> a + " " + b)
                .get();
        return "Usage: java " + options + " [-javaagent:retrolambda.jar] -jar retrolambda.jar\n" +
                "\n" +
                "Retrolambda is a backporting tool for classes which use lambda expressions\n" +
                "and have been compiled with Java 8, to run on Java 7 (maybe even Java 5).\n" +
                "See https://github.com/orfjackal/retrolambda\n" +
                "\n" +
                "Copyright (c) 2013-2015  Esko Luontola <www.orfjackal.net>\n" +
                "This software is released under the Apache License 2.0.\n" +
                "The license text is at http://www.apache.org/licenses/LICENSE-2.0\n" +
                "\n" +
                "Required system properties:\n" +
                "\n" +
                requiredPropertiesHelp.stream().reduce((a, b) -> a + "\n" + b).get() +
                "\n" +
                "Optional system properties:\n" +
                "\n" +
                optionalPropertiesHelp.stream().reduce((a, b) -> a + "\n" + b).get() +
                "\n" +
                "If the Java agent is used, then Retrolambda will use it to capture the\n" +
                "lambda classes generated by Java. Otherwise Retrolambda will hook into\n" +
                "Java's internal lambda dumping API, which is more susceptible to suddenly\n" +
                "stopping to work between Java releases.\n";
    }

    private static void requiredParameterHelp(String key, String... lines) {
        requiredProperties.add(key);
        requiredPropertiesHelp.add(formatPropertyHelp(key, lines));
    }

    private static void optionalParameterHelp(String key, String... lines) {
        optionalPropertiesHelp.add(formatPropertyHelp(key, lines));
    }

    private static String formatPropertyHelp(String key, String... lines) {
        String s = "  " + key + "\n";
        for (String line : lines) {
            s += "      " + line + "\n";
        }
        return s;
    }
}
